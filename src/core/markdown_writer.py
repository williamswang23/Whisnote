# Copyright (c) 2025, Williams.Wang. All rights reserved. Use restricted under LICENSE terms.

"""
Markdown输出模块

将转写文本格式化并保存为Markdown文件。
"""

from datetime import datetime
from pathlib import Path
from typing import Optional, Dict, Any

from ..utils.config import Config


class MarkdownWriter:
    """Markdown文档写入器类"""
    
    def __init__(self, output_dir: Optional[Path] = None) -> None:
        """
        初始化Markdown写入器
        
        Args:
            output_dir: 输出目录，默认使用配置中的目录
        """
        self.output_dir = output_dir or Config.get_output_dir()
        
    def save_transcription(
        self,
        text: str,
        audio_file_path: Optional[Path] = None,
        metadata: Optional[Dict[str, Any]] = None
    ) -> Optional[Path]:
        """
        保存转写文本为Markdown文件
        
        Args:
            text: 转写文本
            audio_file_path: 原始音频文件路径
            metadata: 额外的元数据信息
            
        Returns:
            Optional[Path]: 保存的Markdown文件路径，失败返回None
        """
        try:
            # 生成文件名（精确到秒，确保每次都是新文件）
            timestamp = datetime.now()
            filename = f"voice_note_{timestamp.strftime('%Y%m%d_%H%M%S')}.md"
            
            # 如果文件已存在，在文件名后添加毫秒确保唯一性
            output_path = self.output_dir / filename
            counter = 1
            while output_path.exists():
                base_name = f"voice_note_{timestamp.strftime('%Y%m%d_%H%M%S')}_{counter:03d}.md"
                output_path = self.output_dir / base_name
                counter += 1
            
            # 生成Markdown内容
            content = self._generate_markdown_content(
                text, timestamp, audio_file_path, metadata
            )
            
            # 写入文件
            output_path.write_text(content, encoding='utf-8')
            
            print(f"📄 Markdown saved: {output_path}")
            return output_path
            
        except Exception as e:
            print(f"❌ Error saving Markdown: {e}")
            return None
    
    def _generate_markdown_content(
        self,
        text: str,
        timestamp: datetime,
        audio_file_path: Optional[Path] = None,
        metadata: Optional[Dict[str, Any]] = None
    ) -> str:
        """
        生成Markdown内容
        
        Args:
            text: 转写文本
            timestamp: 时间戳
            audio_file_path: 音频文件路径
            metadata: 元数据
            
        Returns:
            str: 格式化的Markdown内容
        """
        # 基本信息
        formatted_time = timestamp.strftime("%Y-%m-%d %H:%M:%S")
        
        # 构建Markdown内容
        lines = [
            f"# Voice Note - {formatted_time}",
            "",
            "## Transcription",
            "",
            text,
            "",
            "---",
            "",
            "## Metadata",
            "",
            f"- **Created:** {formatted_time}",
            f"- **Word Count:** {len(text.split())}",
            f"- **Character Count:** {len(text)}"
        ]
        
        # 添加音频文件信息
        if audio_file_path:
            # 使用相对路径显示音频文件位置
            relative_path = f"./audio/{audio_file_path.name}"
            lines.extend([
                f"- **Audio File:** `{audio_file_path.name}`",
                f"- **Audio Path:** `{relative_path}`"
            ])
        
        # 添加额外元数据
        if metadata:
            lines.append("")
            lines.append("### Additional Info")
            lines.append("")
            
            for key, value in metadata.items():
                if isinstance(value, (str, int, float, bool)):
                    lines.append(f"- **{key.title()}:** {value}")
                elif isinstance(value, dict):
                    lines.append(f"- **{key.title()}:**")
                    for sub_key, sub_value in value.items():
                        lines.append(f"  - {sub_key}: {sub_value}")
        
        # 添加时间戳脚注
        lines.extend([
            "",
            "---",
            "",
            f"*Generated by Voice Transcription Tool at {formatted_time}*"
        ])
        
        return "\n".join(lines)
    
    def append_to_daily_log(
        self,
        text: str,
        audio_file_path: Optional[Path] = None
    ) -> Optional[Path]:
        """
        将转写文本追加到当日日志文件
        
        Args:
            text: 转写文本
            audio_file_path: 音频文件路径
            
        Returns:
            Optional[Path]: 日志文件路径
        """
        try:
            # 生成当日日志文件名
            today = datetime.now()
            daily_log_name = f"daily_log_{today.strftime('%Y%m%d')}.md"
            log_path = self.output_dir / daily_log_name
            
            # 准备要追加的内容
            timestamp = today.strftime("%H:%M:%S")
            entry_lines = [
                f"## {timestamp}",
                "",
                text,
                ""
            ]
            
            if audio_file_path:
                entry_lines.extend([
                    f"*Source: {audio_file_path.name}*",
                    ""
                ])
            
            entry_lines.append("---")
            entry_lines.append("")
            
            entry_content = "\n".join(entry_lines)
            
            # 如果文件不存在，创建带标题的新文件
            if not log_path.exists():
                header = f"# Daily Voice Notes - {today.strftime('%Y-%m-%d')}\n\n"
                log_path.write_text(header + entry_content, encoding='utf-8')
            else:
                # 追加到现有文件
                with open(log_path, 'a', encoding='utf-8') as f:
                    f.write(entry_content)
            
            print(f"📝 Added to daily log: {log_path}")
            return log_path
            
        except Exception as e:
            print(f"❌ Error updating daily log: {e}")
            return None
    
    def create_summary_file(self, entries: list, summary_text: str) -> Optional[Path]:
        """
        创建摘要文件
        
        Args:
            entries: 条目列表
            summary_text: 摘要文本
            
        Returns:
            Optional[Path]: 摘要文件路径
        """
        try:
            timestamp = datetime.now()
            summary_name = f"summary_{timestamp.strftime('%Y%m%d_%H%M%S')}.md"
            summary_path = self.output_dir / summary_name
            
            lines = [
                f"# Voice Notes Summary - {timestamp.strftime('%Y-%m-%d %H:%M:%S')}",
                "",
                "## Summary",
                "",
                summary_text,
                "",
                "## Source Entries",
                ""
            ]
            
            for i, entry in enumerate(entries, 1):
                lines.extend([
                    f"### Entry {i}",
                    "",
                    entry[:200] + ("..." if len(entry) > 200 else ""),
                    ""
                ])
            
            summary_path.write_text("\n".join(lines), encoding='utf-8')
            
            print(f"📊 Summary saved: {summary_path}")
            return summary_path
            
        except Exception as e:
            print(f"❌ Error creating summary: {e}")
            return None
    
    def get_recent_files(self, limit: int = 10) -> list:
        """
        获取最近的Markdown文件列表
        
        Args:
            limit: 返回文件数量限制
            
        Returns:
            list: 最近文件路径列表
        """
        try:
            md_files = list(self.output_dir.glob("*.md"))
            # 按修改时间排序
            md_files.sort(key=lambda x: x.stat().st_mtime, reverse=True)
            return md_files[:limit]
        except Exception:
            return []
    
    def get_stats(self) -> Dict[str, Any]:
        """
        获取输出统计信息
        
        Returns:
            Dict[str, Any]: 统计信息
        """
        try:
            md_files = list(self.output_dir.glob("*.md"))
            total_files = len(md_files)
            
            total_size = sum(f.stat().st_size for f in md_files if f.exists())
            
            return {
                "output_dir": str(self.output_dir),
                "total_files": total_files,
                "total_size_bytes": total_size,
                "total_size_mb": round(total_size / (1024 * 1024), 2),
                "recent_files": [f.name for f in self.get_recent_files(5)]
            }
        except Exception:
            return {
                "output_dir": str(self.output_dir),
                "total_files": 0,
                "total_size_bytes": 0,
                "total_size_mb": 0,
                "recent_files": []
            } 