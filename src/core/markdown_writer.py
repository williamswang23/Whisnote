# Copyright (c) 2025, Williams.Wang. All rights reserved. Use restricted under LICENSE terms.

"""
Markdownè¾“å‡ºæ¨¡å—

å°†è½¬å†™æ–‡æœ¬æ ¼å¼åŒ–å¹¶ä¿å­˜ä¸ºMarkdownæ–‡ä»¶ã€‚
"""

from datetime import datetime
from pathlib import Path
from typing import Optional, Dict, Any

from ..utils.config import Config


class MarkdownWriter:
    """Markdownæ–‡æ¡£å†™å…¥å™¨ç±»"""
    
    def __init__(self, output_dir: Optional[Path] = None) -> None:
        """
        åˆå§‹åŒ–Markdownå†™å…¥å™¨
        
        Args:
            output_dir: è¾“å‡ºç›®å½•ï¼Œé»˜è®¤ä½¿ç”¨é…ç½®ä¸­çš„ç›®å½•
        """
        self.output_dir = output_dir or Config.get_output_dir()
        
    def save_transcription(
        self,
        text: str,
        audio_file_path: Optional[Path] = None,
        metadata: Optional[Dict[str, Any]] = None
    ) -> Optional[Path]:
        """
        ä¿å­˜è½¬å†™æ–‡æœ¬ä¸ºMarkdownæ–‡ä»¶
        
        Args:
            text: è½¬å†™æ–‡æœ¬
            audio_file_path: åŸå§‹éŸ³é¢‘æ–‡ä»¶è·¯å¾„
            metadata: é¢å¤–çš„å…ƒæ•°æ®ä¿¡æ¯
            
        Returns:
            Optional[Path]: ä¿å­˜çš„Markdownæ–‡ä»¶è·¯å¾„ï¼Œå¤±è´¥è¿”å›None
        """
        try:
            # ç”Ÿæˆæ–‡ä»¶åï¼ˆç²¾ç¡®åˆ°ç§’ï¼Œç¡®ä¿æ¯æ¬¡éƒ½æ˜¯æ–°æ–‡ä»¶ï¼‰
            timestamp = datetime.now()
            filename = f"voice_note_{timestamp.strftime('%Y%m%d_%H%M%S')}.md"
            
            # å¦‚æœæ–‡ä»¶å·²å­˜åœ¨ï¼Œåœ¨æ–‡ä»¶ååæ·»åŠ æ¯«ç§’ç¡®ä¿å”¯ä¸€æ€§
            output_path = self.output_dir / filename
            counter = 1
            while output_path.exists():
                base_name = f"voice_note_{timestamp.strftime('%Y%m%d_%H%M%S')}_{counter:03d}.md"
                output_path = self.output_dir / base_name
                counter += 1
            
            # ç”ŸæˆMarkdownå†…å®¹
            content = self._generate_markdown_content(
                text, timestamp, audio_file_path, metadata
            )
            
            # å†™å…¥æ–‡ä»¶
            output_path.write_text(content, encoding='utf-8')
            
            print(f"ğŸ“„ Markdown saved: {output_path}")
            return output_path
            
        except Exception as e:
            print(f"âŒ Error saving Markdown: {e}")
            return None
    
    def _generate_markdown_content(
        self,
        text: str,
        timestamp: datetime,
        audio_file_path: Optional[Path] = None,
        metadata: Optional[Dict[str, Any]] = None
    ) -> str:
        """
        ç”ŸæˆMarkdownå†…å®¹
        
        Args:
            text: è½¬å†™æ–‡æœ¬
            timestamp: æ—¶é—´æˆ³
            audio_file_path: éŸ³é¢‘æ–‡ä»¶è·¯å¾„
            metadata: å…ƒæ•°æ®
            
        Returns:
            str: æ ¼å¼åŒ–çš„Markdownå†…å®¹
        """
        # åŸºæœ¬ä¿¡æ¯
        formatted_time = timestamp.strftime("%Y-%m-%d %H:%M:%S")
        
        # æ„å»ºMarkdownå†…å®¹
        lines = [
            f"# Voice Note - {formatted_time}",
            "",
            "## Transcription",
            "",
            text,
            "",
            "---",
            "",
            "## Metadata",
            "",
            f"- **Created:** {formatted_time}",
            f"- **Word Count:** {len(text.split())}",
            f"- **Character Count:** {len(text)}"
        ]
        
        # æ·»åŠ éŸ³é¢‘æ–‡ä»¶ä¿¡æ¯
        if audio_file_path:
            # ä½¿ç”¨ç›¸å¯¹è·¯å¾„æ˜¾ç¤ºéŸ³é¢‘æ–‡ä»¶ä½ç½®
            relative_path = f"./audio/{audio_file_path.name}"
            lines.extend([
                f"- **Audio File:** `{audio_file_path.name}`",
                f"- **Audio Path:** `{relative_path}`"
            ])
        
        # æ·»åŠ é¢å¤–å…ƒæ•°æ®
        if metadata:
            lines.append("")
            lines.append("### Additional Info")
            lines.append("")
            
            for key, value in metadata.items():
                if isinstance(value, (str, int, float, bool)):
                    lines.append(f"- **{key.title()}:** {value}")
                elif isinstance(value, dict):
                    lines.append(f"- **{key.title()}:**")
                    for sub_key, sub_value in value.items():
                        lines.append(f"  - {sub_key}: {sub_value}")
        
        # æ·»åŠ æ—¶é—´æˆ³è„šæ³¨
        lines.extend([
            "",
            "---",
            "",
            f"*Generated by Voice Transcription Tool at {formatted_time}*"
        ])
        
        return "\n".join(lines)
    
    def append_to_daily_log(
        self,
        text: str,
        audio_file_path: Optional[Path] = None
    ) -> Optional[Path]:
        """
        å°†è½¬å†™æ–‡æœ¬è¿½åŠ åˆ°å½“æ—¥æ—¥å¿—æ–‡ä»¶
        
        Args:
            text: è½¬å†™æ–‡æœ¬
            audio_file_path: éŸ³é¢‘æ–‡ä»¶è·¯å¾„
            
        Returns:
            Optional[Path]: æ—¥å¿—æ–‡ä»¶è·¯å¾„
        """
        try:
            # ç”Ÿæˆå½“æ—¥æ—¥å¿—æ–‡ä»¶å
            today = datetime.now()
            daily_log_name = f"daily_log_{today.strftime('%Y%m%d')}.md"
            log_path = self.output_dir / daily_log_name
            
            # å‡†å¤‡è¦è¿½åŠ çš„å†…å®¹
            timestamp = today.strftime("%H:%M:%S")
            entry_lines = [
                f"## {timestamp}",
                "",
                text,
                ""
            ]
            
            if audio_file_path:
                entry_lines.extend([
                    f"*Source: {audio_file_path.name}*",
                    ""
                ])
            
            entry_lines.append("---")
            entry_lines.append("")
            
            entry_content = "\n".join(entry_lines)
            
            # å¦‚æœæ–‡ä»¶ä¸å­˜åœ¨ï¼Œåˆ›å»ºå¸¦æ ‡é¢˜çš„æ–°æ–‡ä»¶
            if not log_path.exists():
                header = f"# Daily Voice Notes - {today.strftime('%Y-%m-%d')}\n\n"
                log_path.write_text(header + entry_content, encoding='utf-8')
            else:
                # è¿½åŠ åˆ°ç°æœ‰æ–‡ä»¶
                with open(log_path, 'a', encoding='utf-8') as f:
                    f.write(entry_content)
            
            print(f"ğŸ“ Added to daily log: {log_path}")
            return log_path
            
        except Exception as e:
            print(f"âŒ Error updating daily log: {e}")
            return None
    
    def create_summary_file(self, entries: list, summary_text: str) -> Optional[Path]:
        """
        åˆ›å»ºæ‘˜è¦æ–‡ä»¶
        
        Args:
            entries: æ¡ç›®åˆ—è¡¨
            summary_text: æ‘˜è¦æ–‡æœ¬
            
        Returns:
            Optional[Path]: æ‘˜è¦æ–‡ä»¶è·¯å¾„
        """
        try:
            timestamp = datetime.now()
            summary_name = f"summary_{timestamp.strftime('%Y%m%d_%H%M%S')}.md"
            summary_path = self.output_dir / summary_name
            
            lines = [
                f"# Voice Notes Summary - {timestamp.strftime('%Y-%m-%d %H:%M:%S')}",
                "",
                "## Summary",
                "",
                summary_text,
                "",
                "## Source Entries",
                ""
            ]
            
            for i, entry in enumerate(entries, 1):
                lines.extend([
                    f"### Entry {i}",
                    "",
                    entry[:200] + ("..." if len(entry) > 200 else ""),
                    ""
                ])
            
            summary_path.write_text("\n".join(lines), encoding='utf-8')
            
            print(f"ğŸ“Š Summary saved: {summary_path}")
            return summary_path
            
        except Exception as e:
            print(f"âŒ Error creating summary: {e}")
            return None
    
    def get_recent_files(self, limit: int = 10) -> list:
        """
        è·å–æœ€è¿‘çš„Markdownæ–‡ä»¶åˆ—è¡¨
        
        Args:
            limit: è¿”å›æ–‡ä»¶æ•°é‡é™åˆ¶
            
        Returns:
            list: æœ€è¿‘æ–‡ä»¶è·¯å¾„åˆ—è¡¨
        """
        try:
            md_files = list(self.output_dir.glob("*.md"))
            # æŒ‰ä¿®æ”¹æ—¶é—´æ’åº
            md_files.sort(key=lambda x: x.stat().st_mtime, reverse=True)
            return md_files[:limit]
        except Exception:
            return []
    
    def get_stats(self) -> Dict[str, Any]:
        """
        è·å–è¾“å‡ºç»Ÿè®¡ä¿¡æ¯
        
        Returns:
            Dict[str, Any]: ç»Ÿè®¡ä¿¡æ¯
        """
        try:
            md_files = list(self.output_dir.glob("*.md"))
            total_files = len(md_files)
            
            total_size = sum(f.stat().st_size for f in md_files if f.exists())
            
            return {
                "output_dir": str(self.output_dir),
                "total_files": total_files,
                "total_size_bytes": total_size,
                "total_size_mb": round(total_size / (1024 * 1024), 2),
                "recent_files": [f.name for f in self.get_recent_files(5)]
            }
        except Exception:
            return {
                "output_dir": str(self.output_dir),
                "total_files": 0,
                "total_size_bytes": 0,
                "total_size_mb": 0,
                "recent_files": []
            } 